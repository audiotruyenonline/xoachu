<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Web X√≥a Ch·ªØ Trong TXT</title>
<style>
  :root{
    --bg:#0f172a; --card:#1e293b; --muted:#94a3b8; --txt:#e2e8f0;
    --btn:#3b82f6; --btn2:#0ea5e9; --danger:#ef4444; --ok:#22c55e; --line:#334155;
    --in:#0b1224;
  }
  *{box-sizing:border-box}
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--txt);}
  .wrap{max-width:1100px;margin:auto;padding:14px;}
  h1{margin:0 0 10px 0;font-size:20px;letter-spacing:.2px}
  .hint{color:var(--muted);font-size:12px;margin:6px 0 0}
  .card{background:var(--card);border-radius:14px;padding:12px;margin-bottom:12px; border:1px solid rgba(255,255,255,.06);}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .meta{font-size:12px;color:var(--muted);margin-bottom:8px}
  textarea{
    width:100%;
    min-height:34vh;
    padding:10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.06);
    background:var(--in);
    color:var(--txt);
    resize:vertical;
    font-size:13px;
    line-height:1.5;
  }
  input[type="text"]{
    width: min(520px, 100%);
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.06);
    background:var(--in);
    color:var(--txt);
    outline:none;
  }
  input[type="file"]{
    background:var(--in);
    padding:8px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.06);
    color:var(--txt);
    max-width:100%;
  }
  button{
    padding:10px 12px;
    border:none;
    border-radius:12px;
    cursor:pointer;
    background:var(--btn);
    color:white;
    font-weight:700;
    box-shadow: 0 10px 25px rgba(0,0,0,.25);
  }
  button:active{transform:translateY(1px)}
  button.alt{background:var(--btn2)}
  button.ok{background:var(--ok)}
  button.danger{background:var(--danger)}
  .btnGrid{
    display:grid;
    grid-template-columns: repeat(3, minmax(0,1fr));
    gap:10px;
    width:100%;
  }
  @media (max-width: 820px){
    .btnGrid{grid-template-columns: repeat(2, minmax(0,1fr));}
    textarea{min-height:33vh;}
  }
  .chips{
    display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;
  }
  .chip{
    padding:8px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.08);
    background: rgba(11,18,36,.55);
    color: var(--txt);
    font-weight:700;
    cursor:pointer;
    user-select:none;
  }
  .chip:active{transform:translateY(1px)}
  .chipMain{
    background: rgba(34,197,94,.20);
    border-color: rgba(34,197,94,.38);
  }
  .splitMeta{
    display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
  }
  .stat{
    font-size:12px; color:var(--muted);
    padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.08);
    background: rgba(11,18,36,.45);
  }
  details{margin-top:10px}
  summary{cursor:pointer; color:var(--txt); font-weight:800}
  .small{font-size:12px;color:var(--muted);margin-top:6px;line-height:1.4}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Web X√≥a T·ª´ Trong TXT</h1>

    <!-- TOP: INPUT TXT -->
    <div class="card">
      <div class="meta">Tr√™n: TXT g·ªëc (t·∫£i .txt ho·∫∑c d√°n). Gi·ªØa: n√∫t x√≥a/d·ªçn. D∆∞·ªõi: k·∫øt qu·∫£.</div>
      <div class="row" style="margin-bottom:10px">
        <input type="file" id="fileInput" accept=".txt" />
        <button class="alt" id="btnPasteToInput" title="ƒê∆∞a k·∫øt qu·∫£ xu·ªëng d∆∞·ªõi l√™n TXT g·ªëc ƒë·ªÉ x·ª≠ l√Ω ti·∫øp">KQ ‚Üí TXT g·ªëc</button>
      </div>
      <textarea id="inputTxt" placeholder="D√°n n·ªôi dung TXT v√†o ƒë√¢y..."></textarea>
      <div class="hint">M·∫πo: b·∫•m ‚ÄúD·ªçn s·∫°ch nhanh (V4)‚Äù ƒë·ªÉ x√≥a Qidian/UUKANSHU/‚ä•/(T·∫•u ch∆∞∆°ng xong)/d√≤ng c√≥ URL/k√Ω t·ª± r√°c ch·ªâ 1 ph√°t.</div>
    </div>

    <!-- MIDDLE: ACTIONS -->
    <div class="card">
      <div class="splitMeta">
        <div class="meta" style="margin:0">Gi·ªØa: thao t√°c nhanh</div>
        <div class="stat">ƒê√£ x√≥a: <b id="count">0</b> | K√Ω t·ª± KQ: <b id="charCount">0</b> | D√≤ng KQ: <b id="lineCount">0</b></div>
      </div>

      <div class="row" style="margin-top:10px">
        <input type="text" id="needle" placeholder="Nh·∫≠p t·ª´/c·ª•m t·ª´ mu·ªën x√≥a (VD: qu·∫£ng c√°o)" />
      </div>

      <div class="btnGrid" style="margin-top:10px">
        <button id="btnRemove">X√≥a (c·ª•m t·ª´)</button>
        <button id="btnRemoveLine" class="alt">X√≥a c·∫£ d√≤ng ch·ª©a t·ª´</button>
        <button id="btnCleanV4" class="ok">D·ªçn s·∫°ch nhanh (V4)</button>
        <button id="btnCopy" class="alt">Copy K·∫øt Qu·∫£</button>
        <button id="btnDownload" class="alt">T·∫£i TXT</button>
        <button id="btnClear" class="danger">X√≥a H·∫øt</button>
      </div>

        <div class="chips">
          <div class="chip chipMain" data-preset="all">üî• X√≥a T·∫§T C·∫¢ (1 l·∫ßn ·∫•n)</div>
        <div class="chips">
          <div class="chip chipMain" data-clean="pro4">‚ö° L√†m s·∫°ch nhanh (g·ªôp + d√≤ng tr·ªëng + k√Ω t·ª± ·∫©n + d·∫•u c√¢u)</div>
        </div>

    <!-- BOTTOM: OUTPUT TXT -->
    <div class="card">
      <div class="meta">D∆∞·ªõi: K·∫øt qu·∫£</div>
      <textarea id="outputTxt" placeholder="K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y..." readonly></textarea>
    </div>
  </div>

<script>
  const fileInput = document.getElementById("fileInput");
  const inputTxt  = document.getElementById("inputTxt");
  const outputTxt = document.getElementById("outputTxt");
  const needle    = document.getElementById("needle");

  const countEl   = document.getElementById("count");
  const charCount = document.getElementById("charCount");
  const lineCount = document.getElementById("lineCount");

  const btnRemove = document.getElementById("btnRemove");
  const btnRemoveLine = document.getElementById("btnRemoveLine");
  const btnCleanV4 = document.getElementById("btnCleanV4");
  const btnCopy   = document.getElementById("btnCopy");
  const btnDownload = document.getElementById("btnDownload");
  const btnClear  = document.getElementById("btnClear");
  const btnPasteToInput = document.getElementById("btnPasteToInput");

  let lastRemoved = 0;

  function countLines(s){
    if(!s) return 0;
    return s.split(/\r\n|\r|\n/).length;
  }

  function updateStats(){
    const out = outputTxt.value || "";
    charCount.textContent = out.length;
    lineCount.textContent = countLines(out);
    countEl.textContent = lastRemoved || 0;
  }

  fileInput.addEventListener("change", function(){
    const file = this.files && this.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      inputTxt.value = e.target.result || "";
      outputTxt.value = "";
      lastRemoved = 0;
      updateStats();
    };
    reader.readAsText(file, "UTF-8");
  });

  function escapeRegExp(str){
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function setOutput(text, removed){
    outputTxt.value = text || "";
    lastRemoved = removed || 0;
    updateStats();
  }

  function removeText(){
    const source = inputTxt.value || "";
    const word = (needle.value || "").trim();
    if(!source.trim()){ setOutput("", 0); return; }
    if(!word){ setOutput(source, 0); return; }

    const regex = new RegExp(escapeRegExp(word), "gi");
    let removed = 0;
    const result = source.replace(regex, () => { removed++; return ""; });
    setOutput(result, removed);
  }

  function removeLineContainingWord(){
    const source = inputTxt.value || "";
    const word = (needle.value || "").trim();
    if(!source.trim()){ setOutput("", 0); return; }
    if(!word){ setOutput(source, 0); return; }

    const re = new RegExp(escapeRegExp(word), "i");
    let removed = 0;
    const lines = source.split(/\r\n|\r|\n/);
    const kept = lines.filter(line => {
      if(re.test(line)){ removed++; return false; }
      return true;
    });
    setOutput(kept.join("\n"), removed);
  }

  // ===== Presets (x√≥a nhanh d√≤ng) =====
  function presetRemove(type){
    const source = inputTxt.value || "";
    if(!source.trim()){ setOutput("", 0); return; }
    let removed = 0;
    let lines = source.split(/\r\n|\r|\n/);

    const reQidian = /Truy·ªán ƒë∆∞·ª£c ƒëƒÉng t·∫°i\s*https?:\/\/[^\s]+\/truyen\/qidian\/1\/1047673087\/\d+\/\.?/i;
    const reUukanshu = /UUKANSHU.*www\.uukanshu\.com/i;
    const reTau = /\(\s*T·∫•u\s*ch∆∞∆°ng\s*xong\s*\)/i;
    const reUrl = /https?:\/\//i;

    if(type === "qidian"){
      lines = lines.filter(l => !(reQidian.test(l) ? (removed++, true) : false));
      return setOutput(lines.join("\n"), removed);
    }
    if(type === "uukanshu"){
      lines = lines.filter(l => !(reUukanshu.test(l) ? (removed++, true) : false));
      return setOutput(lines.join("\n"), removed);
    }
    if(type === "perp"){
      lines = lines.filter(l => !((l.includes("‚ä•")) ? (removed++, true) : false));
      return setOutput(lines.join("\n"), removed);
    }
    if(type === "tauch"){
      lines = lines.filter(l => !(reTau.test(l) ? (removed++, true) : false));
      return setOutput(lines.join("\n"), removed);
    }
    if(type === "urls"){
      lines = lines.filter(l => !(reUrl.test(l) ? (removed++, true) : false));
      return setOutput(lines.join("\n"), removed);
    }
    if(type === "trashchars"){
      // x√≥a k√Ω t·ª± r√°c trong to√†n b·ªô text (kh√¥ng x√≥a c·∫£ d√≤ng)
      let text = source;
      // ‚Äî ~ "
      const beforeLen = text.length;
      text = text.replace(/[‚Äî~"]/g, "");
      // ".)" -> ")" (xo√° d·∫•u ch·∫•m tr∆∞·ªõc d·∫•u ngo·∫∑c)
      text = text.replace(/\.\)/g, ")");
      // g·ªôp nhi·ªÅu kho·∫£ng tr·∫Øng
      text = text.replace(/[ \t]+/g, " ");
      removed = Math.max(0, beforeLen - text.length);
      return setOutput(text, removed);
    }
  }

  // ===== Clean helpers =====
  function removeHiddenChars(text){
    // BOM + zero width chars
    return (text || "")
      .replace(/^\uFEFF/, "")
      .replace(/[\u200B-\u200D\u2060]/g, "");
  }

  function fixPunct(text){
    let t = text || "";

    // 1) G·ªôp d·∫•u c√¢u l·∫∑p l·∫°i th√†nh 1 cho nh√≥m: ! ? . , ( )
    // V√≠ d·ª•: !!! -> !, ???? -> ?, ... -> ., ))) -> )
    t = t.replace(/([!?\.,\(\)])\1+/g, "$1");

    // 2) B·ªè kho·∫£ng tr·∫Øng tr∆∞·ªõc d·∫•u c√¢u (.,!?))
    t = t.replace(/\s+([!?\.,\)])/g, "$1");

    // 3) B·ªè kho·∫£ng tr·∫Øng th·ª´a sau "("
    t = t.replace(/\(\s+/g, "(");

    // 4) Th√™m 1 kho·∫£ng tr·∫Øng sau d·∫•u c√¢u n·∫øu d√≠nh ch·ªØ ngay sau (tr·ª´ xu·ªëng d√≤ng)
    t = t.replace(/([!?\.,])([^\s\n\r])/g, "$1 $2");

    return t;
  }

  function cleanSpaces(text){
    return (text || "")
      .split(/\r\n|\r|\n/)
      .map(line => line.replace(/[ \t]+/g, " ").trim())
      .join("\n");
  }

  function removeEmptyLines(text){
    return (text || "")
      .split(/\r\n|\r|\n/)
      .filter(line => line.trim().length > 0)
      .join("\n");
  }

  function cleanPro(text){
    let t = text || "";

    // G·ªôp c√°c b∆∞·ªõc: x√≥a k√Ω t·ª± ·∫©n + g·ªôp kho·∫£ng tr·∫Øng + x√≥a d√≤ng tr·ªëng + s·ª≠a d·∫•u c√¢u l·∫∑p
    t = removeHiddenChars(t);
    t = cleanSpaces(t);
    t = removeEmptyLines(t);
    t = fixPunct(t);

    // Ch·∫°y l·∫°i g·ªôp kho·∫£ng tr·∫Øng/d√≤ng tr·ªëng sau khi s·ª≠a d·∫•u c√¢u
    t = cleanSpaces(t);
    t = removeEmptyLines(t);

    // Gi·∫£m c√°c c·ª•m xu·ªëng d√≤ng qu√° nhi·ªÅu
    t = t.replace(/\n{3,}/g, "\n\n");
    return t;
  }

  function cleanV4(){
    const source = inputTxt.value || "";
    if(!source.trim()){ setOutput("", 0); return; }
    let removed = 0;
    let t = source;

    // 1) x√≥a footer Qidian trong to√†n vƒÉn b·∫£n (kh√¥ng c·∫ßn xu·ªëng d√≤ng ƒë√∫ng)
    const reQidianAll = /Truy·ªán ƒë∆∞·ª£c ƒëƒÉng t·∫°i\s*https?:\/\/[^\s]+\/truyen\/qidian\/1\/1047673087\/\d+\/\.?/gi;
    t = t.replace(reQidianAll, () => { removed++; return ""; });

    // 2) x√≥a UUKANSHU line fragments
    const reUukAll = /UUKANSHU.*www\.uukanshu\.com/gi;
    t = t.replace(reUukAll, () => { removed++; return ""; });

    // 3) x√≥a (T·∫•u ch∆∞∆°ng xong)
    const reTauAll = /\(\s*T·∫•u\s*ch∆∞∆°ng\s*xong\s*\)/gi;
    t = t.replace(reTauAll, () => { removed++; return ""; });

    // 4) x√≥a k√Ω t·ª± r√°c ‚Äî ~ " v√† s·ª≠a .)
    t = t.replace(/[‚Äî~"]/g, "");
    t = t.replace(/\.\)/g, ")");

    // 5) x√≥a c√°c d√≤ng ch·ª©a ‚ä• ho·∫∑c c√≥ URL (http/https)
    const lines = t.split(/\r\n|\r|\n/);
    let removedLines = 0;
    const kept = lines.filter(line => {
      const hit = line.includes("‚ä•") || /https?:\/\//i.test(line);
      if(hit){ removedLines++; return false; }
      return true;
    });
    t = kept.join("\n");
    removed += removedLines;

    // 6) l√†m s·∫°ch cu·ªëi
    t = cleanPro(t);

    setOutput(t, removed);
  }

  async function copyText(){
    const val = outputTxt.value || "";
    if(!val) return;
    try{
      await navigator.clipboard.writeText(val);
      alert("ƒê√£ copy!");
    }catch(e){
      outputTxt.focus();
      outputTxt.select();
      document.execCommand("copy");
      alert("ƒê√£ copy!");
    }
  }

  function downloadTxt(){
    const val = outputTxt.value || "";
    if(!val) return;
    const blob = new Blob([val], {type:"text/plain;charset=utf-8"});
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "ket-qua.txt";
    link.click();
    setTimeout(()=>URL.revokeObjectURL(link.href), 800);
  }

  function clearAll(){
    inputTxt.value = "";
    outputTxt.value = "";
    needle.value = "";
    lastRemoved = 0;
    updateStats();
  }

  function pasteResultToInput(){
    const val = outputTxt.value || "";
    if(!val) return;
    inputTxt.value = val;
    outputTxt.value = "";
    lastRemoved = 0;
    updateStats();
  }

  // ===== Wire up =====
  btnRemove.addEventListener("click", removeText);
  btnRemoveLine.addEventListener("click", removeLineContainingWord);
  btnCleanV4.addEventListener("click", cleanV4);
  btnCopy.addEventListener("click", copyText);
  btnDownload.addEventListener("click", downloadTxt);
  btnClear.addEventListener("click", clearAll);
  btnPasteToInput.addEventListener("click", pasteResultToInput);

  document.querySelectorAll("[data-preset]").forEach(el=>{
    el.addEventListener("click", ()=> presetRemove(el.getAttribute("data-preset")));
  });

  document.querySelectorAll("[data-clean]").forEach(el=>{
    el.addEventListener("click", ()=>{
      const kind = el.getAttribute("data-clean");
      const source = inputTxt.value || "";
      if(!source.trim()){ setOutput("",0); return; }
      let t = outputTxt.value ? outputTxt.value : source; // ∆∞u ti√™n l√†m s·∫°ch tr√™n KQ n·∫øu c√≥
      let removed = 0;
      const before = t;

      if(kind === "pro4") t = cleanPro(t);
// l√†m s·∫°ch nh·∫π cu·ªëi
      t = t.replace(/\n{3,}/g, "\n\n");
      removed = Math.max(0, before.length - t.length);
      setOutput(t, removed);
    });
  });

  // init
  updateStats();
</script>
</body>
</html>
